using Microsoft.Extensions.Configuration;
using Xunit;
using System.Globalization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization.Metadata;
using System;
using System.Linq;
using System.IO;
using System.Collections.Generic;
using System.Buffers;
using Xunit.Abstractions;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Linq;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace Fededim.Extensions.Configuration.Protected.DataProtectionAPITest
{
    /// <summary>
    /// Possibile movement inside a hierarchical structure: stays at the same level (Current), Go down another level (Down), go up the previous level (Up)
    /// </summary>
    public enum LevelMove { Current, Down, Up };

    /// <summary>
    /// All possible datatypes generated by this test class
    /// </summary>
    public enum DataTypes { Null, String, Integer, Double, Boolean, DateTimeOffset, StringArray, IntegerArray, DoubleArray, BooleanArray, DateTimeOffsetArray }


    /// <summary>
    /// Provides general context to all tests, it is executed once before all tests
    /// </summary>
    public class ProtectedConfigurationBuilderTestFixture : IDisposable
    {
        public ProtectedConfigurationBuilderTestFixture()
        {
            // cleans existing XML, JSON and BAK files
            Directory.EnumerateFiles(".", "*.json").ToList().ForEach(f => File.Delete(f));
            Directory.EnumerateFiles(".", "*.xml").ToList().ForEach(f => File.Delete(f));
            Directory.EnumerateFiles(".", "*.bak").ToList().ForEach(f => File.Delete(f));
        }

        public void Dispose()
        {
        }
    }


    public abstract class ProtectedConfigurationBuilderTest
    {
        const int NUMENTRIES = 5000;
        const int STRINGMAXLENGTH = 20;
        const int ARRAYMAXLENGTH = 10;
        const int SUBPURPOSEMAXLENGTH = 8;


        protected String RANDOMJSONFILENAME => $"random_{Random.Next()}.json";
        protected String RANDOMXMLFILENAME => $"random_{Random.Next()}.xml";

        Random Random { get; } = new Random();

        protected DataTypes[] DataTypesValues = (DataTypes[])Enum.GetValues(typeof(DataTypes));
        protected LevelMove[] LevelMoveValues = (LevelMove[])Enum.GetValues(typeof(LevelMove));
        protected TimeZoneInfo[] TimeZoneInfoValues = TimeZoneInfo.GetSystemTimeZones().ToArray();

        protected IProtectProviderConfigurationData ProtectProviderConfigurationData { get; set; }
        protected JsonSerializerOptions JsonSerializerOptions { get; set; }
        protected ITestOutputHelper TestOutputHelper { get; set; }
        protected ProtectedConfigurationBuilderTestFixture Context { get; set; }


        public ProtectedConfigurationBuilderTest(ProtectedConfigurationBuilderTestFixture context, ITestOutputHelper testOutputHelper, IProtectProviderConfigurationData protectProviderConfigurationData)
        {
            Context = context;
            ProtectProviderConfigurationData = protectProviderConfigurationData;
            TestOutputHelper = testOutputHelper;

            JsonSerializerOptions = new JsonSerializerOptions { WriteIndented = true, TypeInfoResolver = new DefaultJsonTypeInfoResolver() };
        }

        protected ProtectedConfigurationBuilderTest()
        {
        }


        /// <summary>
        /// Generates a random ascii string (valid characters from 32 to 126)
        /// </summary>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        protected String GenerateRandomString(int maxLength)
        {
            var stringBuilder = new StringBuilder();

            for (int i = 0; i < Random.Next(1, maxLength); i++)
                stringBuilder.Append(Convert.ToChar(Random.Next(32, 126)));

            return stringBuilder.ToString();

        }



        /// <summary>
        /// custom NextInt64 implementation (missing in net462)
        /// </summary>
        /// <param name="minValue">minimum value for the integer</param>
        /// <param name="maxValue">maximum value for the integer</param>
        /// <returns></returns>
        protected Int64 NextInt64(Int64 minValue, Int64 maxValue)
        {
            return minValue + (Int64)((UInt64)(Random.NextDouble() * ((UInt64)(maxValue - minValue))));
        }



        /// <summary>
        /// helper method to create random values both in datatype and value
        /// </summary>
        /// <returns>tuple with a random datatype <see cref="DataTypes"/> and a random value</returns>
        protected (DataTypes DataType, object Value) GenerateRandomValue()
        {
            var dataType = (DataTypes)DataTypesValues.GetValue(Random.Next(DataTypesValues.Length));

            switch (dataType)
            {
                case DataTypes.Null:
                    return (dataType, null);

                case DataTypes.String:
                    return (dataType, TrimStringValue(GenerateRandomString(STRINGMAXLENGTH)));

                case DataTypes.Integer:
                    return (dataType, NextInt64(Int64.MinValue, Int64.MaxValue));

                case DataTypes.DateTimeOffset:
                    return (dataType, new DateTimeOffset(NextInt64(DateTimeOffset.MinValue.Ticks, DateTimeOffset.MaxValue.Ticks), TimeZoneInfoValues[Random.Next(TimeZoneInfoValues.Length)].BaseUtcOffset));

                case DataTypes.Double:
                    return (dataType, NextInt64(Int64.MinValue, Int64.MaxValue) * Random.NextDouble());

                case DataTypes.Boolean:
                    return (dataType, (Random.Next() % 2 == 0) ? true : false);

                case DataTypes.StringArray:
                    var stringArray = new String[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < stringArray.Length; i++)
                    {
                        stringArray[i] = TrimStringValue(GenerateRandomString(STRINGMAXLENGTH));
                    }
                    return (dataType, stringArray);

                case DataTypes.BooleanArray:
                    var booleanArray = new Boolean[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < booleanArray.Length; i++)
                        booleanArray[i] = (Random.Next() % 2 == 0) ? true : false;
                    return (dataType, booleanArray);

                case DataTypes.IntegerArray:
                    var integerArray = new Int64[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < integerArray.Length; i++)
                        integerArray[i] = NextInt64(Int64.MinValue, Int64.MaxValue);
                    return (dataType, integerArray);

                case DataTypes.DateTimeOffsetArray:
                    var dateTimeArray = new DateTimeOffset[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < dateTimeArray.Length; i++)
                        dateTimeArray[i] = new DateTimeOffset(NextInt64(DateTimeOffset.MinValue.Ticks, DateTimeOffset.MaxValue.Ticks), TimeZoneInfoValues[Random.Next(TimeZoneInfoValues.Length)].BaseUtcOffset);
                    return (dataType, dateTimeArray);

                case DataTypes.DoubleArray:
                    var doubleArray = new Double[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < doubleArray.Length; i++)
                        doubleArray[i] = NextInt64(Int64.MinValue, Int64.MaxValue) * Random.NextDouble();
                    return (dataType, doubleArray);

                default:
                    throw new NotSupportedException($"Datatype not supported {dataType}!");
            }
        }



        #region "Json Tests and helper methods"

        /// <summary>
        /// Helper method used by <see cref="CreateJsonProtectValue"/> used to convert object values to string.
        /// </summary>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns></returns>
        protected String EntryToJsonValue(DataTypes dataType, object value)
        {
            switch (dataType)
            {
                // with strings we do not need to perform another JSON encoding, it will be done at the end of the generation process when saving the JSON file
                case DataTypes.String:
                case DataTypes.StringArray:
                    return value.ToString();

                // for some unknown reason the standard extension method AddJsonFile of ConfigurationBuilder converts boolean lowercase values (true,false) inside a JSON file into upper case boolean strings (True,False)
                // so in order to test everything is fine we need to "serialize" them also in upper case inside Protect:{} tokens
                // when deserializing into a class there in no problem, both false and False will be converted to boolean false and both true and True will be converted to boolean true
                case DataTypes.Boolean:
                case DataTypes.BooleanArray:
                    return String.Format(CultureInfo.InvariantCulture, "{0}", value);

                default:
                    // we remove the " characters,they are already added by CreateJsonProtectValue method
                    return JsonSerializer.Serialize(value, JsonSerializerOptions).Replace("\"", "");
            }
        }


        /// <summary>
        /// Creates a Protect:{<dataToEncrypt>} string for <see cref="GenerateRandomJsonFile"/>
        /// </summary>
        /// <param name="subPurpose">per configuration value encryption subkey (e.g. "subpurposes")</param>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns>the generated Protect:{<dataToEncrypt>} string</returns>
        protected String CreateJsonProtectValue(string subPurpose, DataTypes dataType, object value)
        {
            if (value == null)
                return null;

            return (subPurpose != null) ? $"Protect:{{{subPurpose}}}:{{{EntryToJsonValue(dataType, value)}}}" : $"Protect:{{{EntryToJsonValue(dataType, value)}}}";
        }


        /// <summary>
        /// generates a random hierarchical JSON file with random NUMENTRIES in both datatype and value
        /// </summary>
        /// <returns>the generated filename</returns>
        protected String GenerateRandomJsonFile()
        {
            String subPurpose;
            var fileName = RANDOMJSONFILENAME;

            var JSONObject = new JsonObject();

            var currentNode = JSONObject;

            int level = 1;

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var levelMove = (LevelMove)LevelMoveValues.GetValue(Random.Next(LevelMoveValues.Length));

                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;
                        currentNode[entryKey + "Plaintext"] = JsonValue.Create(entryValue.Value);
                        currentNode[entryKey + "Encrypted"] = JsonValue.Create(CreateJsonProtectValue(subPurpose, entryValue.DataType, entryValue.Value));
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        currentNode[entryKey + "Plaintext"] = new JsonArray(((Array)entryValue.Value).Cast<object>().Select(obj => JsonValue.Create(obj)).ToArray());
                        currentNode[entryKey + "Encrypted"] = new JsonArray(((Array)entryValue.Value).Cast<object>().Select(obj =>
                        {
                            subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;
                            return JsonValue.Create(CreateJsonProtectValue(subPurpose, entryValue.DataType, obj));
                        }).ToArray());
                        break;
                }

                if (levelMove == LevelMove.Down && level < 62)
                {
                    var nextSubLevelKey = $"Sublevel_{++level}";

                    if (!currentNode.ContainsKey(nextSubLevelKey))
                        currentNode[nextSubLevelKey] = new JsonObject();

                    currentNode = currentNode[nextSubLevelKey].AsObject();
                }
                else if (levelMove == LevelMove.Up && level > 1)
                {
                    level--;
                    currentNode = currentNode.Parent.AsObject();
                }
            }


            File.WriteAllText(fileName, JSONObject.ToJsonString(JsonSerializerOptions));

            var fileInfo = new FileInfo(fileName);
            TestOutputHelper.WriteLine($"Generated a random JSON file with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}");
            TestOutputHelper.WriteLine($"File location file://{Path.GetFullPath(fileName).Replace("\\", "/")} size {fileInfo.Length / 1024}KB, starting test...");

            return fileName;
        }


        /// <summary>
        /// Generates random json file with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomJsonFileTest()
        {
            // genererates a JSON file
            var fileName = GenerateRandomJsonFile();


            // Encrypts the JSON file
            Assert.True(ProtectProviderConfigurationData.ProtectFiles(".")?.Any());


            // Reads the encrypted JSON file and checks that all encrypted entries do not match DefaultProtectRegexString
            var encryptedJsonDocument = JsonSerializer.Deserialize<Dictionary<string, object>>(File.ReadAllText(fileName), JsonSerializerOptions);
            foreach (var node in encryptedJsonDocument)
            {
                if (node.Key.Contains("_Encrypted") && node.Value != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(node.Value.ToString()))
                        throw new InvalidDataException($"Found an invalid un-encrypted node Key {node.Key} Value {node.Value}!");
            }


            // Loads the JSON with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddJsonFile(fileName).Build();

            // For each xxx_Plaintext key check that its value is equal to xxx_Encrypted
            ExtractAllConfigurationKeys(configuration).ForEach(key =>
            {
                if (key.Contains("_Plaintext"))
                {
                    var encryptedKey = key.Replace("_Plaintext", "_Encrypted");
                    if (configuration[key] != configuration[encryptedKey])
                        throw new InvalidDataException($"Value mismatch: Plaintext Key {key} Value {configuration[key]} Encrypted Key {encryptedKey} Value {configuration[encryptedKey]}");
                }
            });
        }


        #endregion





        #region "XML Tests and helper methods"

        /// <summary>
        /// Helper method used by <see cref="CreateXmlProtectValue"/> used to convert object values to string.
        /// </summary>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns></returns>
        protected String EntryToXmlValue(DataTypes dataType, object value)
        {
            // performs value serialization
            switch (dataType)
            {
                // with strings we do not need to perform another XML encoding, it will be done at the end of the generation process when saving the XML file
                case DataTypes.String:
                case DataTypes.StringArray:
                    return value.ToString();

                //// for some unknown reason the standard extension method AddJsonFile of ConfigurationBuilder converts boolean lowercase values (true,false) inside a JSON file into upper case boolean strings (True,False)
                //// so in order to test everything is fine we need to "serialize" them also in upper case inside Protect:{} tokens
                //// when deserializing into a class there in no problem, both false and False will be converted to boolean false and both true and True will be converted to boolean true
                //case DataTypes.Boolean:
                //case DataTypes.BooleanArray:
                //    return String.Format(CultureInfo.InvariantCulture, "{0}", value);

                default:
                    return ToXmlString(value);
            }

        }



        /// <summary>
        /// Helper method used to encode XML fragments (e.g. raw values)
        /// </summary>
        /// <param name="value">an input value</param>
        /// <returns>the encode XML string representing the input value</returns>
        protected String ToXmlString(object value)
        {
            using (var stringWriter = new StringWriter())
            {
                using (var xmlWriter = new XmlTextWriter(stringWriter))
                {
                    xmlWriter.WriteValue(value);
                    return stringWriter.ToString();
                }
            }
        }



        /// <summary>
        /// Creates a Protect:{<dataToEncrypt>} string for <see cref="GenerateRandomXmlFile"/>
        /// </summary>
        /// <param name="subPurpose">per configuration value encryption subkey (e.g. "subpurposes")</param>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns>the generated Protect:{<dataToEncrypt>} string</returns>
        protected String CreateXmlProtectValue(string subPurpose, DataTypes dataType, object value)
        {
            if (value == null)
                return null;

            return (subPurpose != null) ? $"Protect:{{{subPurpose}}}:{{{EntryToXmlValue(dataType, value)}}}" : $"Protect:{{{EntryToXmlValue(dataType, value)}}}";
        }




        /// <summary>
        /// Adds a random node to the current XmlDocument either an as attribute or as an element
        /// </summary>
        /// <param name="currentNode">the node on which the new node will be added</param>
        /// <param name="name">the new node name</param>
        /// <param name="value">the new node value</param>
        /// <param name="forceElement">if true, forces the new node to be an element</param>
        /// <returns>always true</returns>
        public bool AddXmlNode(XmlNode currentNode, string name, object value, bool forceElement = false)
        {
            String valueString = null;

            var attributeNode = (!forceElement && Random.Next() % 4 == 0) ? true : false;

            if (value != null)
                valueString = ToXmlString(value);

            if (attributeNode)
            {
                var attribute = currentNode.OwnerDocument.CreateAttribute(name);
                attribute.Value = valueString;
                currentNode.Attributes.Append(attribute);
            }
            else
            {
                var element = currentNode.OwnerDocument.CreateElement(name);
                element.InnerText = valueString;
                currentNode.AppendChild(element);
            }

            return true;
        }



        /// <summary>
        /// Generates hierarchical XML file with random NUMENTRIES in both datatype and value
        /// </summary>
        /// <returns>the generated filename</returns>
        protected String GenerateRandomXmlFile()
        {
            String subPurpose;
            var fileName = RANDOMXMLFILENAME;

            // 
            var xmlDocument = new XmlDocument();
            xmlDocument.AppendChild(xmlDocument.CreateElement("root"));

            var currentNode = xmlDocument.DocumentElement;

            int level = 1;

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var levelMove = (LevelMove)LevelMoveValues.GetValue(Random.Next(LevelMoveValues.Length));

                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        AddXmlNode(currentNode, entryKey + "Plaintext", entryValue.Value);
                        AddXmlNode(currentNode, entryKey + "Encrypted", CreateXmlProtectValue(subPurpose, entryValue.DataType, entryValue.Value));
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        var arrayElement = xmlDocument.CreateElement(entryKey + "Plaintext");
                        ((Array)entryValue.Value).Cast<object>().Select((obj, index) => AddXmlNode(arrayElement, $"A_{index}", obj, true)).ToArray();
                        currentNode.AppendChild(arrayElement);

                        arrayElement = xmlDocument.CreateElement(entryKey + "Encrypted");
                        ((Array)entryValue.Value).Cast<object>().Select((obj, index) =>
                        {
                            subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;
                            return AddXmlNode(arrayElement, $"A_{index}", CreateXmlProtectValue(subPurpose, entryValue.DataType, obj), true);
                        }).ToArray();
                        currentNode.AppendChild(arrayElement);
                        break;
                }

                if (levelMove == LevelMove.Down && level < 62)
                {
                    var nextSubLevelKey = $"Sublevel_{++level}";

                    if (currentNode.GetElementsByTagName(nextSubLevelKey).Count == 0)
                        currentNode.AppendChild(xmlDocument.CreateElement(nextSubLevelKey));

                    currentNode = (XmlElement)currentNode.GetElementsByTagName(nextSubLevelKey).Item(0);
                }
                else if (levelMove == LevelMove.Up && level > 1)
                {
                    level--;
                    currentNode = (XmlElement)currentNode.ParentNode;
                }
            }


            File.WriteAllText(fileName, xmlDocument.OuterXml);

            var fileInfo = new FileInfo(fileName);
            TestOutputHelper.WriteLine($"Generated a random XML file with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}");
            TestOutputHelper.WriteLine($"File location file://{Path.GetFullPath(fileName).Replace("\\", "/")} size {fileInfo.Length / 1024}KB, starting test...");

            return fileName;
        }



        /// <summary>
        /// Generates random xml file with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomXmlFileTest()
        {
            // genererates a XML file
            var fileName = GenerateRandomXmlFile();


            // Encrypts the XML file
            Assert.True(ProtectProviderConfigurationData.ProtectFiles(".", searchPattern: "*.xml")?.Any());


            // Reads the encrypted XML file and checks that all encrypted entries do not match DefaultProtectRegexString
            var encryptedXmlDocument = XDocument.Load(fileName);
            foreach (var node in encryptedXmlDocument.Descendants())
            {
                // check element is encrypted
                if (node.Name.LocalName.Contains("_Encrypted") && node.Value != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(node.Value.ToString()))
                        throw new InvalidDataException($"Found an invalid un-encrypted element Key {node.Name.LocalName} Value {node.Value}!");

                // check all its attributes are encrypted
                foreach (var attribute in node.Attributes())
                    if (attribute.Name.LocalName.Contains("_Encrypted") && attribute.Value != null)
                        if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(attribute.Value.ToString()))
                            throw new InvalidDataException($"Found an invalid un-encrypted attribute Key {attribute.Name.LocalName} Value {attribute.Value}!");
            }


            // Loads the XML with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddXmlFile(fileName).Build();

            // For each xxx_Plaintext key check that its value is equal to xxx_Encrypted
            ExtractAllConfigurationKeys(configuration).ForEach(key =>
            {
                if (key.Contains("_Plaintext"))
                {
                    var encryptedKey = key.Replace("_Plaintext", "_Encrypted");
                    if (configuration[key] != configuration[encryptedKey])
                        throw new InvalidDataException($"Value mismatch: Plaintext Key {key} Value {configuration[key]} Encrypted Key {encryptedKey} Value {configuration[encryptedKey]}");
                }
            });
        }

        #endregion






        #region "Environment variables Tests and helper methods"

        /// <summary>
        /// Helper method used to convert object values to protect pure string (no encoding).
        /// </summary>
        /// <param name="subPurpose">per configuration value encryption subkey (e.g. "subpurposes")</param>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns></returns>
        protected String CreateStringProtectValue(string subPurpose, DataTypes dataType, object value)
        {
            if (value == null)
                return null;

            return (subPurpose != null) ? $"Protect:{{{subPurpose}}}:{{{value}}}" : $"Protect:{{{value}}}";
        }


        /// <summary>
        /// Generates random environment variables with (2*NUMENTRIES) in both datatype and value. Environment variables can only contain string and they aren't hierarchical.
        /// </summary>
        protected void GenerateRandomEnvironmentVariables()
        {
            String subPurpose;
            var fileName = RANDOMXMLFILENAME;

            // Generate random environments variables
            // 
            for (int i = 0; i < NUMENTRIES; i++)
            {
                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        Environment.SetEnvironmentVariable(entryKey + "Plaintext", entryValue.Value?.ToString(), EnvironmentVariableTarget.Process);
                        Environment.SetEnvironmentVariable(entryKey + "Encrypted", CreateStringProtectValue(subPurpose, entryValue.DataType, entryValue.Value), EnvironmentVariableTarget.Process);
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        // environment variables do not support arrays, we take first value
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        var firstValue = ((Array)entryValue.Value).Cast<object>()?.FirstOrDefault()?.ToString();

                        Environment.SetEnvironmentVariable(entryKey + "Plaintext", firstValue, EnvironmentVariableTarget.Process);
                        Environment.SetEnvironmentVariable(entryKey + "Encrypted", CreateStringProtectValue(subPurpose, entryValue.DataType, firstValue), EnvironmentVariableTarget.Process);
                        break;
                }
            }


            TestOutputHelper.WriteLine($"Generated a random environment variables {NUMENTRIES} entries, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}");
            TestOutputHelper.WriteLine($"Starting test...");
        }


        /// <summary>
        /// Generates random process environment variables with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomEnvironmentVariablesTest()
        {
            // genererates random environment variables
            GenerateRandomEnvironmentVariables();


            // Encrypts the environment variables
            ProtectProviderConfigurationData.ProtectEnvironmentVariables(EnvironmentVariableTarget.Process);


            // Checks that all environment variables are encrypted, e.g. do not match DefaultProtectRegexString
            var environmentVariables = Environment.GetEnvironmentVariables(EnvironmentVariableTarget.Process);
            foreach (String key in environmentVariables.Keys)
            {
                if (key.Contains("_Encrypted") && environmentVariables[key] != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(environmentVariables[key].ToString()))
                        throw new InvalidDataException($"Found an invalid un-encrypted environment variable {key} Value {environmentVariables[key]}!");
            }


            // Loads the XML with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddEnvironmentVariables().Build();

            // For each xxx_Plaintext key check that its value is equal to xxx_Encrypted
            ExtractAllConfigurationKeys(configuration).ForEach(key =>
            {
                if (key.Contains("_Plaintext"))
                {
                    var encryptedKey = key.Replace("_Plaintext", "_Encrypted");
                    if (configuration[key] != configuration[encryptedKey])
                        throw new InvalidDataException($"Value mismatch: Plaintext Key {key} Value {configuration[key]} Encrypted Key {encryptedKey} Value {configuration[encryptedKey]}");
                }
            });
        }
        #endregion





        #region "In-Memory dictionary Tests and helper methods"

        /// <summary>
        /// Generates a random in-memory dictionary with random 2*NUMENTRIES in both datatype and value. In-memory dictionary can only contain string and it isn't hierarchical.
        /// </summary>
        /// <returns>the generated in-memory dictionary</returns>
        protected Dictionary<String, String> GenerateRandomInMemoryDictionary()
        {
            String subPurpose;

            var dictionary = new Dictionary<String, String>();

            var currentNode = dictionary;

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        currentNode[entryKey + "Plaintext"] = entryValue.Value?.ToString();
                        currentNode[entryKey + "Encrypted"] = CreateStringProtectValue(subPurpose, entryValue.DataType, entryValue.Value);
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        // in-memory dictionaries do not support arrays, we take first value
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        var firstValue = ((Array)entryValue.Value).Cast<object>()?.FirstOrDefault()?.ToString();

                        currentNode[entryKey + "Plaintext"] = firstValue;
                        currentNode[entryKey + "Encrypted"] = CreateStringProtectValue(subPurpose, entryValue.DataType, firstValue);
                        break;
                }
            }


            TestOutputHelper.WriteLine($"Generated a random in-memory dictionary with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}");
            TestOutputHelper.WriteLine($"Starting test...");

            return dictionary;
        }


        /// <summary>
        /// Generates random in-memory dictionary with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomInMemoryDictionaryTest()
        {
            // genererates random in-memory dictionary
            var dictionary = GenerateRandomInMemoryDictionary();


            // Encrypts the in-memory dictionary
            ProtectProviderConfigurationData.ProtectConfigurationValue(dictionary);


            // Checks that all entries of the in-memory dictioary are encrypted, e.g. do not match DefaultProtectRegexString
            foreach (var entry in dictionary)
            {
                if (entry.Key.Contains("_Encrypted") && entry.Value != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(entry.Value))
                        throw new InvalidDataException($"Found an invalid un-encrypted environment variable {entry.Key} Value {entry.Value}!");
            }


            // Loads the in-memory dictionary with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddInMemoryCollection(dictionary).Build();

            // Foreach xxx_Plaintext key check that its value is equal to xxx_Encrypted
            ExtractAllConfigurationKeys(configuration).ForEach(key =>
            {
                if (key.Contains("_Plaintext"))
                {
                    var encryptedKey = key.Replace("_Plaintext", "_Encrypted");
                    if (configuration[key] != configuration[encryptedKey])
                        throw new InvalidDataException($"Value mismatch: Plaintext Key {key} Value {configuration[key]} Encrypted Key {encryptedKey} Value {configuration[encryptedKey]}");
                }
            });
        }
        #endregion





        #region "Command line Tests and helper methods"

        /// <summary>
        /// Generates command line arguments with random (4*NUMENTRIES) in both datatype and value. Command line arguments can only contain string and they aren't hierarchical.
        /// </summary>
        /// <returns>the generated arguments array</returns>
        protected String[] GenerateRandomCommandLine()
        {
            String subPurpose;

            var args = new String[4 * NUMENTRIES];

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        args[4 * i] = $"--{entryKey}Plaintext";
                        args[4 * i + 1] = entryValue.Value?.ToString();
                        args[4 * i + 2] = $"--{entryKey}Encrypted";
                        args[4 * i + 3] = CreateStringProtectValue(subPurpose, entryValue.DataType, entryValue.Value);
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        // command line arguments do not support arrays, we take first value
                        subPurpose = (Random.Next() % 4 == 0) ? TrimStringSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        var firstValue = ((Array)entryValue.Value).Cast<object>()?.FirstOrDefault()?.ToString();

                        args[4 * i] = $"--{entryKey}Plaintext";
                        args[4 * i + 1] = firstValue;
                        args[4 * i + 2] = $"--{entryKey}Encrypted";
                        args[4 * i + 3] = CreateStringProtectValue(subPurpose, entryValue.DataType, firstValue);
                        break;
                }
            }


            TestOutputHelper.WriteLine($"Generated a random command line arguments with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}");
            TestOutputHelper.WriteLine($"Starting test...");

            return args;
        }


        /// <summary>
        /// Generates random command line arguments with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomCommandLineTest()
        {
            // genererates random command line arguments
            var args = GenerateRandomCommandLine();


            // Encrypts the command line arguments
            var encryptedArgs = ProtectProviderConfigurationData.ProtectConfigurationValue(args);


            // Checks that all command line arguments are encrypted, e.g. do not match DefaultProtectRegexString
            for (int i = 0; i < encryptedArgs.Length / 2; i++)
            {
                if (encryptedArgs[2 * i].Contains("_Encrypted") && encryptedArgs[2 * i + 1] != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(encryptedArgs[2 * i + 1]))
                        throw new InvalidDataException($"Found an invalid un-encrypted environment variable {encryptedArgs[2 * i]} Value {encryptedArgs[2 * i + 1]}!");
            }


            // Loads the command line arguments with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddCommandLine(encryptedArgs).Build();

            // For each xxx_Plaintext key check that its value is equal to xxx_Encrypted
            ExtractAllConfigurationKeys(configuration).ForEach(key =>
            {
                if (key.Contains("_Plaintext"))
                {
                    var encryptedKey = key.Replace("_Plaintext", "_Encrypted");
                    if (configuration[key] != configuration[encryptedKey])
                        throw new InvalidDataException($"Value mismatch: Plaintext Key {key} Value {configuration[key]} Encrypted Key {encryptedKey} Value {configuration[encryptedKey]}");
                }
            });
        }
        #endregion




        /// <summary>
        /// Extracts all configuration keys from IConfiguration or IConfigurationRoot
        /// </summary>
        /// <param name="configurationRoot"></param>
        /// <returns></returns>
        protected List<String> ExtractAllConfigurationKeys(IConfiguration configurationRoot)
        {
            var result = new List<String>();

            // For each xxx_Plaintext key check that its value is equal to xxx_Encrypted
            foreach (var key in configurationRoot.GetChildren())
            {
                var childKeys = ExtractAllConfigurationKeys(key);

                if (childKeys.Any())
                    result.AddRange(childKeys);
                else
                    result.Add(key.Path);
            }

            return result;
        }



        /// <summary>
        /// This method is used to remove characters which are used inside the subPurpose group of the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex
        /// </summary>
        /// <remarks>There is no easy way to extract this logic directly fromm the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex, so you have to implement it by yourself in your test according to the regex you use</remarks>
        /// <param name="subpurpose">a random autogenerated subpurpose string</param>
        /// <returns>the random autogenerated subpurpose string with the characters used in the regex removed or replaced</returns>
        protected abstract string TrimStringSubpurpose(string subpurpose);



        /// <summary>
        /// This method is used to remove characters which are used inside the protectData group of the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex
        /// </summary>
        /// <remarks>There is no easy way to extract this logic directly fromm the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex, so you have to implement it by yourself in your test according to the regex you use</remarks>
        /// <param name="value">a random autogenerated value string</param>
        /// <returns>the random autogenerated value string with the characters used in the regex removed or replaced</returns>
        protected abstract string TrimStringValue(string value);
    }
}
